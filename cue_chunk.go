package wav

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"

	"github.com/go-audio/riff"
)

var (
	// ErrCuePointIDNotFound is returned when cue point ID cannot be read.
	ErrCuePointIDNotFound = errors.New("failed to read the cue point ID")
	// ErrDataChunkIDNotFound is returned when data chunk ID cannot be read.
	ErrDataChunkIDNotFound = errors.New("failed to read the data chunk id")
	errCueNilChunk         = errors.New("can't decode a nil chunk")
	errCueNilDecoder       = errors.New("nil decoder")
)

// CuePoint defines an offset which marks a noteworthy sections of the audio
// content. For example, the beginning and end of a verse in a song may have cue
// points to make them easier to find.
type CuePoint struct {
	// ID is the unique identifier of the cue point
	ID [4]byte
	// Play position specifies the sample offset associated with the cue point
	// in terms of the sample's position in the final stream of samples
	// generated by the play list. If a play list chunk is
	// specified, the position value is equal to the sample number at which this
	// cue point will occur during playback of the entire play list as defined
	// by the play list's order. If no play list chunk is specified this value
	// should be 0.
	Position uint32
	// DataChunkID - This value specifies the four byte ID used by the chunk
	// containing the sample that corresponds to this cue point. A Wave file
	// with no play list is always "data". A Wave file with a play list
	// containing both sample data and silence may be either "data" or "slnt".
	DataChunkID [4]byte
	// ChunkStart specifies the byte offset into the Wave List Chunk of the
	// chunk containing the sample that corresponds to this cue point. This is
	// the same chunk described by the Data Chunk ID value. If no Wave List
	// Chunk exists in the Wave file, this value is 0. If a Wave List Chunk
	// exists, this is the offset into the "wavl" chunk. The first chunk in the
	// Wave List Chunk would be specified with a value of 0.
	ChunkStart uint32
	// BlockStart specifies the byte offset into the "data" or "slnt" Chunk to
	// the start of the block containing the sample. The start of a block is
	// defined as the first byte in uncompressed PCM wave data or the last byte
	// in compressed wave data where decompression can begin to find the value
	// of the corresponding sample value.
	BlockStart uint32
	// SampleOffset specifies an offset into the block (specified by Block
	// Start) for the sample that corresponds to the cue point. In uncompressed
	// PCM waveform data, this is simply the byte offset into the "data" chunk.
	// In compressed waveform data, this value is equal to the number of samples
	// (may or may not be bytes) from the Block Start to the sample that
	// corresponds to the cue point.
	SampleOffset uint32
}

// DecodeCueChunk decodes the optional cue chunk and extracts cue points.
func DecodeCueChunk(d *Decoder, ch *riff.Chunk) error {
	if ch == nil {
		return errCueNilChunk
	}

	if d == nil {
		return errCueNilDecoder
	}

	if ch.ID == CIDCue {
		// read the entire chunk in memory
		buf := make([]byte, ch.Size)

		n, err := io.ReadFull(ch, buf)
		if err != nil && !errors.Is(err, io.EOF) && !errors.Is(err, io.ErrUnexpectedEOF) {
			return fmt.Errorf("failed to read the CUE chunk - %w", err)
		}

		buf = buf[:n]

		reader := bytes.NewReader(buf)

		var nbrCues uint32
		if err := binary.Read(reader, binary.LittleEndian, &nbrCues); err != nil {
			return fmt.Errorf("failed to read the number of cues - %w", err)
		}

		if nbrCues > 0 {
			if d.Metadata == nil {
				d.Metadata = &Metadata{}
			}

			d.Metadata.CuePoints = []*CuePoint{}
			scratch := make([]byte, 4)

			for range nbrCues {
				c := &CuePoint{}

				if _, err = reader.Read(scratch); err != nil {
					return ErrCuePointIDNotFound
				}

				copy(c.ID[:], scratch[:4])

				err := binary.Read(reader, binary.LittleEndian, &c.Position)
				if err != nil {
					return fmt.Errorf("failed to read cue point position: %w", err)
				}

				if _, err = reader.Read(scratch); err != nil {
					return fmt.Errorf("failed to read data chunk ID: %w", err)
				}

				copy(c.DataChunkID[:], scratch[:4])

				err = binary.Read(reader, binary.LittleEndian, &c.ChunkStart)
				if err != nil {
					return fmt.Errorf("failed to read chunk start: %w", err)
				}

				err = binary.Read(reader, binary.LittleEndian, &c.BlockStart)
				if err != nil {
					return fmt.Errorf("failed to read block start: %w", err)
				}

				err = binary.Read(reader, binary.LittleEndian, &c.SampleOffset)
				if err != nil {
					return fmt.Errorf("failed to read sample offset: %w", err)
				}

				d.Metadata.CuePoints = append(d.Metadata.CuePoints, c)
			}
		}
	}

	return nil
}
